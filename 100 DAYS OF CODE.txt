100 DAYS OF CODE

1. You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.

APPROACH:
(LOOP FOR LENGTH OF TOKENS ARRAY)
I. TAKE EACH TOKEN AND IF ITS A NUMBER CONVERT IT TO INT AND STORE IT IN STACK
II. IF THE TOKEN IS AN OPERATOR, POP OUT TWO ELEMENTS FROM THE STACK, THEN PERFORM THE
OPERATION AND PUSH THE RESULT AGAIN INTO THE STACK
III. FINALLY RETURN THE TOP MOST ELEMENT OF THE STACK

def evalRPN(self, tokens: List[str]) -> int:
        stack = []

        for i in range(len(tokens)):
            if tokens[i] in "+-/*":
                num1 = stack.pop()
                num2 = stack.pop()

                if tokens[i] == "+":
                    stack.append(num2 + num1)
                
                if tokens[i] == "-":
                    stack.append(num2 - num1)

                if tokens[i] == "*":
                    stack.append(num2 * num1)

                if tokens[i] == "/":
                    stack.append(int(num2 / num1))

            else:
                stack.append(int(tokens[i]))
        
        return stack[-1]

-----------------------------------------------------------------------------------------------------------------------------------

2. Combination Sum with a twist.


APPROACH:
I. CREATE AN ARRAY FROM DIGITS 1 TO 9
II. DEFINE THE RECURSIVE FUNCTION STARTING FROM IDX = 0 TILL IDX = 9
I.E VALUES 1 TO 9. ALSO THE PARAMETERS WOULD BE EMPTY LST AND CURR TARGET
III. BASE CASE FOR RECURSION--> IF TARGET == 0---> CHECK IF LEN(LST) == K
IF TRUE THEN ADD THE ELEMENTS FROM THE LST TO FINAL ANS...ELSE RETURN
IV. RECURSION LOGIC
ITERATE FROM CURR_IDX TO LAST_IDX = 9
IF ARR[CURR_IDX] > CURR_TARGET---> BREAK THE LOOP (CURR RECURSION CALL WILL BE OVER)
ELSE--> ADD THE ARR[I] TO LST
RECUSTION CALL WITH PARAMS CURR_IDX+1, CURR_TARGET-ARR[I], LST
ONCE THIS CALL ENDS, POP THE ELEMENT FROM THE LST



def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        arr = [i for i in range(1, 10)]
        ans = []

        def helper(idx, target, lst):
            if target == 0:
                if len(lst) == k:
                    ans.append([el for el in lst])
                return
            
            for i in range(idx, 9):
                if arr[i] > target:
                    break
                lst.append(arr[i])
                helper(i+1, target-arr[i], lst)
                lst.pop()

        helper(0, n, [])
        return ans

--------------------------------------------------------------------------------------------------------------------------------------

3. Bulls and Cows

QUESTION EXPLANATION:
GIVEN TWO STRINGS OF INTEGETS SECRET AND GUESS
BULL IS NUMBER OF POSITIONS IN GUESS THAT ARE SAME AS SECRET I.E
SECRET[I] == GUESS[I]
COW IS NUMBER OF ELEMENTS IN GUESS THAT ARE IN SECRET BUT NOT AT CORRECT POSITION
RETURN BULL-CNT AND COW-CNT

APPROACH:
I. CREATE A BUCKET ARRAY OF 0'S FOR DIGITS 0-9
II. ITERATE OVER BOTH STRINGS
......IF SECRET[I]==GUESS[I]--> INCREMENT THE BULL COUNTER
......ELSE-->BUCKET[SECRET[I]] += 1 AND BUCKET[GUESS[I]] -= 1
III. GET THE SUM OF ALL THE POSITIVE VALUES IN THE BUCKET CALL IT POS-SUM
IV. FINALLY NUMBER OF COWS = LEN(SECRET) - BULL_CNT - POS_CNT


def getHint(self, secret: str, guess: str) -> str:
        bullCnt = 0
        arr = [0 for i in range(10)]

        for i in range(len(secret)):
            if secret[i] == guess[i]:
                bullCnt += 1
            else:
                arr[int(secret[i])] += 1
                arr[int(guess[i])] -= 1
        
        posSum = 0
        for el in arr:
            if el > 0:
                posSum += el

        cows = len(secret) - bullCnt - posSum
        return str(bullCnt) + "A" + str(cows) + "B"

-----------------------------------------------------------------------------------------------------------------------------------------

4. You are given an integer array nums of length n. Return maximum length of Rotation Function.

EXPLANATION:
ROTATION FUNCTION = SUM(EL*IDX FOR EL, IDX_VAL IN ARR) OR
ROTATION FUNCTION(0) = 0*ARR[0] + 1*ARR[1] + ...
NOW,
ROTATION FUNCTION(1) = 1*ARR[0] + 2*ARR[1] + ... + N-1*ARR[N-1] + 0*ARR[N]

WE HAVE TO CALCULATE THE MAX OF THESE FUNCTIONS I.E MAX(F(0), F(1), ..F(N))


APPROACH:

BRUTE FORCE
FOR I FROM 1 TO N
-->CALCULATE THE FUNCTION VALUE ONCE
-->ROTATE THE ARRAY BY ONE
RETURN THE MAX VALUE

OPTIMIZED
WE CAN REPRESENT ANY FUNCTION IN TERMS OF THE PREVIOUS ONE

ARR = [4,3,2,6]
EX: F(0) = 0*4 + 1*3 + 2*2 + 3*6
AND F(1) = 1*4 + 2*3 + 3*2 + 0*6
HERE PIVOT OR ROTATION INDEX IS 3 OR ARR[3]
NOW WE CAN SAY F(1) = (0*4 + 4) + (1*3 + 3) + (2*2 + 2) + (3*6 + 6) - 4*6
SO IF GENERALIZE IT
----------MAIN EQ -----------------------------
F(N) = F(N-1) + SUM(ARR) - LEN(ARR)*ARR[PIVOT]

I. CALCULATE THE SUM OF ARRAY AND F (FOR FIRST TIME)
II. ITERATE FROM PIVOT = N-1 TO 0
III. IN EACH ITERATION CALCULATE F += SUM - N*ARR[PIVOT]
IV. ANS = MAX(F, ANS)
V. RETURN ANS


def maxRotateFunction(self, nums: List[int]) -> int:
        n = len(nums)
        s = sum(nums)
        fn = sum(el*idx for idx, el in enumerate(nums))
        ans = fn
        for pivot in range(n-1, -1, -1):
            fn += s - n*nums[pivot]
            ans = max(fn, ans)
        return ans

------------------------------------------------------------------------------------------------------------------------------

5. Largest Divisible Subset

PREREQ --> LONGEST INCREASING SUBSEQUENCE


def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        n = len(nums)
        dp = [1] * n
        store = [0] * n
        lastIdx = 0
        maxi = 1
        nums.sort()

        for i in range(n):
            store[i] = i
            for prev in range(0, i):
                if (nums[i] % nums[prev] == 0) and (1 + dp[prev] > dp[i]):
                    dp[i] = 1 + dp[prev]
                    store[i] = prev

            if dp[i] > maxi:
                maxi = dp[i]
                lastIdx = i
        
        temp = []
        temp.append(nums[lastIdx])
        while store[lastIdx] != lastIdx:
            lastIdx = store[lastIdx]
            temp.append(nums[lastIdx])

        return temp[::-1]

-------------------------------------------------------------------------------------------------------------------------------

6. How to find a perfect Rectangle.

QEUSTION EXPLANATION:
GIVEN AN ARRAY OF COORDINATES OF RECTANGLES (BOTTOM LEFT AND TOP RIGHT COORDINATES)
CHECK IF ALL RECTANGLES TOGETHER FORM AN EXACT COVER OF RECTANGULAR REGION


APPROACH:
I. FIND THE SMALLEST BOTTOM LEFT AND HIGHEST TOP RIGHT COORDINATE
II. FOR EACH RECTANGLE, CALCULATE THE AREA AND ADD IT TO THE TOTAL
III. GET ALL FOUR COORDINATES OF EACH RECTANGLE AND ADD THEM TO A SET
IV. IF A SET ALREADY HAS THAT COORDINATE, REMOVE IT
V. AFTER THE LOOP, CHECK IF LENGTH OF SET IS 4 --> ELSE RETURN FALSE
VI. NOW GET THE POSSIBLE COORDINATES OF THE COVER RECTANGLE USING THE SMALLEST BOTTOM LEFT AND HIGHEST TOP RIGHT COORDINATES AND
CHECK IF IT IS IN THE SET
IF NOT THE RETURN FALSE
VII. CALCULATE THE MAX POSSIBLEE AREA USING SMALLEST BOTTOM LEFT AND HIGHEST TOP RIGHT COORDINATES
VIII. RETURN MAX POSSIBLE AREA == TOTAL AREA



def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        if len(rectangles) == 0:
            return False

        totalArea = 0
        x1, y1 = 1e9, 1e9
        x2, y2 = -1e9, -1e9
        st = set()
        for rect in rectangles:
            x1 = min(x1, rect[0])
            y1 = min(y1, rect[1])
            x2 = max(x2, rect[2])
            y2 = max(y2, rect[3])
            totalArea += ((rect[2]-rect[0]) * (rect[3]-rect[1]))
            
            pt1 = str(rect[0]) + " " + str(rect[1])
            pt2 = str(rect[0]) + " " + str(rect[3])
            pt3 = str(rect[2]) + " " + str(rect[1])
            pt4 = str(rect[2]) + " " + str(rect[3])

            st.add(pt1) if pt1 not in st else st.remove(pt1)
            st.add(pt2) if pt2 not in st else st.remove(pt2)
            st.add(pt3) if pt3 not in st else st.remove(pt3)
            st.add(pt4) if pt4 not in st else st.remove(pt4)


        if (len(st) != 4 or (str(x1) + " " + str(y1) not in st) 
            or (str(x2) + " " + str(y2) not in st) 
            or (str(x1) + " " + str(y2) not in st) 
            or (str(x2) + " " + str(y1) not in st)):
            return False

        possArea = (x2-x1) * (y2-y1)
        return possArea == totalArea

----------------------------------------------------------------------------------------------------------------------------------

7. Scheduling a Course

APPROACH:
USE TOPOLOGICAL SORTING
FOR EACH PAIR U,V U SHOULD APPEAR AFTER/BEFORE V

# using Algorithm for topological sort (BFS)
# indegree = number of incoming edges
# STEP1: CALCULATE INDEGREE OF ALL NODES
# STEP2: INSERT ALL NODES WITH INDEGREE 0 IN THE QUEUE
# STEP3: TAKE EACH OF THEM OUT OF THE QUEUE (PRINT), AND REDUCE THE INDEGREE OF NEIGHBORS, AND IF THE INDEGREE OF NEIGHBORS BECOME 0, ADD THOSE NEIGHBORS IN THE QUEUE


def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = [[] for i in range(numCourses)]
        for it in prerequisites:
            graph[it[0]].append(it[1])

        # Perform Topological Sort
        # (Kahns Algorithm)

        indeg = [0 for i in range(numCourses)]
        for i in range(numCourses):
            for it in graph[i]:
                indeg[it] += 1

        queue = []
        for i in range(numCourses):
            if indeg[i] == 0:
                queue.append(i) 

        topo = []
        while queue:
            node = queue.pop(0)
            topo.append(node)

            for it in graph[node]:
                indeg[it] -= 1
                if indeg[it] == 0:
                    queue.append(it)
        
        if len(topo) == numCourses:
            return True
        return False

--------------------------------------------------------------------------------------------------------------------------------------

8. Profitable Path in a Tree.	(NOT CORRECT)

INTUTION:
IF ALICE REACHES A NODE THAT BOB ALREADY HAS VISITED, THE AMOUNT SHE GETS IS 0
IF ALICE AND BOB BOTH REACH A NODE AT SAME TIME, THEY DIVIDE THE AMOUNT

THUS, CALCULATING THE PARENT AND DISTANCE FROM ROOT I.E ALICE STARTING POINT WILL HELP BOB TO REACH ROOT
ANS ALSO CHECK AT WHICH POINT BOB AND ALICE MEET/ WHICH NODES BOB COVERS FIRST

THEN WE CAN UPDATE THE AMOUNT ARRAY WITH 0 FOR NODES WHERE BOB ALREADY HAS VISITED BEFORE ALICE TO 0
AND THE NODES WHERE BOTH OF THEM REACH TOGETHER TO HALF
I.E BOB_DIST < DISTANCE[BOB_NODE] -- > AMOUNT[BOB_NODE] = 0
ALSO BOB_DIST == DISTANCE[BOB_NODE] -- > AMOUNT[BOB_NODE] /= 2

THEN FINALLY WE CAN PERFORM DFS TRAVERSAL TILL LEAF, GETTING THE MAX POSSIBLE AMOUNT FOR ALICE

APPROACH:
I. CONSTRUCT AN ADJACANCY LIST FROM THE GIVEN EDGES
II. INITIALIZE PARENT AND DISTANCE ARRAYS, VISITED SET
III. FIND PARENT, DISTANCE OF EACH NODE FROM 0
IV. SET INT CURR = BOB, INT CURR_DIST = 0
V. WHILE BOB IS NOT AT 0 UPDATE THE AMOUNT ARRAY
---->IF DISTANCE[CURR] > CURR_DIST THEN AMOUNT[CURR] = 0
---->ELSE IF DISTANCE[CURR] == CURR_DIST THEN AMOUNT[CURR] /= 2
---->  CURR = PARENT[CURR]
----> CURR_DIST += 1
VI. PERFORM DFS FOR ALICE WHILE CALCULATING THE AMOUNT


class Solution:
    tree = {}
    parent = []
    dist = []
    ans = 0
    visited = set()
    maxAns = -1e9


    def constructTree(self, edges):
        n = len(edges)
        for u, v in edges:
            if u not in self.tree:
                self.tree[u] = []
            if v not in self.tree:
                self.tree[v] = []
            self.tree[u].append(v)
            self.tree[v].append(u)


    # Parent of Each Node
    def dfsFindParent(self, curr, currPar, currDist):
        self.dist[curr] = currDist
        self.parent[curr] = currPar

        for neighbor in self.tree[curr]:
            if neighbor == currPar:
                continue
            self.dfsFindParent(neighbor, curr, currDist+1)
    

    def dfs(self, curr, amount):
        self.visited.add(curr)
        self.ans += amount[curr]
        trav = 0

        for neighbor in self.tree[curr]:
            if neighbor in self.visited:
                continue
            trav += 1
            self.dfs(neighbor, amount)
        
        if trav == 0:
            self.maxAns = max(self.ans, self.maxAns)
        
        self.ans -= amount[curr]


    def mostProfitablePath(self, edges, bob, amount):
        self.constructTree(edges)
        n = len(edges)
        self.parent = [-1] * (n+1)
        self.dist = [-1] * (n+1)
        #print(len(self.pa))
        self.dfsFindParent(0,0,0)

        curr = bob
        currDist = 0
        while curr != 0:
            if self.dist[curr] > currDist:
                amount[curr] = 0
            elif self.dist[curr] == currDist:
                amount[curr] /= 2
            
            curr = self.parent[curr]
            currDist += 1
        
        self.dfs(0, amount)
        return int(self.maxAns)
  
----------------------------------------------------------------------------------------------------------------

9. Number of Pairs satisfying Inequality.  (NOT CORRECT)


APPROACH:
GIVEN INEQUALITY:
nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff
FOR I < J 
NOW LETS UPDATE THE INEQUALITY:
nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff
FURTHUR REARRANGING
(nums1[i] - nums2[i]) - (nums1[j] - nums2[j]) <= diff
THUS--> nums[i] - nums[j] <= diff

NOW WE CAN USE DIVIDE AND CONQUER ALGORITHM
THUS MERGE SORT WILL BE HELPFUL
AT THE MERGE STEP, WE CAN AS EACH PART WILL BE SORTED
AND IN ORDER THAT ITH WILL BE IN LEFT AND JTH IN RIGHT,
COUNT THE PAIRS ACCORDING TO THE INEQUALITY


count = 0

    def numberOfPairs(self, nums1: list[int], nums2: list[int], diff: int) -> int:
        n = len(nums1)
        nums = [0] * n
        for i in range(n):
            nums[i] = (nums1[i] - nums2[i])
        
        print(nums)
        self.mergeSort(nums, 0, n-1, diff)
        print(nums)
        return self.count


    def mergeSort(self, arr, low, high, diff):
        if low >= high:
            return
        
        mid = int((low + high) / 2)
        self.mergeSort(arr, low, mid, diff)
        self.mergeSort(arr, mid+1, high, diff)
        self.merge(arr, low, mid, high, diff)

    
    def merge(self, arr, low, mid, high, diff):
        lst = []
        left, right = low, mid+1
        
        while right <= high:
            for i in range(right):
                if arr[i] - diff <= arr[right]:
                    self.count += 1
                # else: break
            right += 1
        
        right = mid+1
        while left <= mid and right <= high:
            if arr[left] <= arr[right]:
                lst.append(arr[left])
                left += 1
            else:
                lst.append(arr[right])
                right += 1
    
        while left <= mid:
            lst.append(arr[left])
            left += 1 

        while right <= high:
            lst.append(arr[right])
            right += 1

        for i in range(low, high+1):
            arr[i] = lst[i-low] 


APPROACH 2:
NOW WE WILL USE THE INEQUALITY AND CREATE A NEW ARRAY TO STORE DIFF OF BOTH AT INDEX
THEN WE WILL USE A  SORTED LIST TO KEEP SEEN NUMBERS SORTED
THEN PERFORM BINARY SEARCH


def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        # [1] it is easily observed that the problem for two arrays
        #     can be restated as a problem for a single array which
        #     equals to their sum;
        nums = np.array(nums1) - np.array(nums2)
        
        # [2] we use SortedList to keep seen numbers sorted
        seen = SortedList()
        count = 0
        
        for n in nums:
            # [3] for sorted lists, performing binary search allows
            #     to obtain the index of insertion in logN time;
            #     this index equals to the amount of numbers (i.e.,
            #     the amount of pairs) that satisfy the condition 
            count += seen.bisect_right(n + diff)
            seen.add(n)
        
        return count


------------------------------------------------------------------------------------------------------

10. Shortest Unsorted continuous Subarray

APPROACH:
CREATE A NEW ARRAY THAT IS SORTED VERSION OF GIVEN ARRAY
FIND THE INDEX FROM STARTING WHERE THE ELEMENTS AT SAME INDEX OF BOTH ARRAYS DO NOT MATCH
SIMILARY FIND THE INDEX FROM THE END
IF ARRAY IS ALREADY SORTED RETURN 0 ELSE RETURN END-START+1

def findUnsortedSubarray(self, nums: List[int]) -> int:
        sorted_nums = sorted(nums)
        st = 0
        end = len(nums) - 1

        while st < len(nums) and nums[st] == sorted_nums[st]:
            st += 1

        while end >= 0 and nums[end] == sorted_nums[end]:
            end -= 1

        return 0 if end <= st else end-st+1

-----------------------------------------------------------------------------------------------------------------

11. Number of ways to arrive at a destination


APPROACH:
DDIJKSTRA'S ALGORITHM
I. CREATE A GRAPH
II. INITIALIZE A DIST, WAYS ARRAYS WITH INF, 0 RESPECTIVELY
III. DIST[0] = 0 AND WAYS[0] = 1
IV. CREATE A MIN_HEAP AND PUSH 0,0 INTO IT I.E (INITIAL DIST, STARTING NODE)
V. WHILE MIN_HEAP IS NOT EMPTY, POP OUT THE TOP MOST ELEMT, THUS WE GET CURR_DIST, NODE
VI. ITERATE OVER THE NEIGHBORS OF NODE
----->FOR EACH ITERATION YOU GET ADJ_NODE, EDGE_WT
-----> IF  CURR_DIST + EDGE_WT < DIST[ADJ_NODE]
-------------> THEN DIST[ADJ_NODE] = CURR_DIST + EDGE_WT
-------------> ALSO WAYS[ADJ_NODE] = WAYS[NODE]
-------------> FINALLY PUSH (CURR_DIST+EDG_WT, ADJ_NODE) IN MIN_HEAP
-----> ELSE IF CURR_DIST + EDGE_WT == DIST[ADJ_NODE]
-------------> TEHN WAYS[ADJ_NODE] += WAYS[NODE]
VII. FINALLY RETURN WAYS[N-1] % 1e9+7


def countPaths(self, n: int, roads: List[List[int]]) -> int:
	if n == 1:
            return 1

        graph = {}
        for u,v,w in roads:
            if u not in graph:
                graph[u] = []
            if v not in graph:
                graph[v] = []
            graph[u].append((v,w))
            graph[v].append((u,w))

        dist = [1e9] * n
        ways = [0] * n
        ways[0] = 1 
        dist[0] = 0
        minHeap = [(0, 0)]
        mod = int(1e9 + 7)

        while minHeap:
            dis, node = heapq.heappop(minHeap)

            for adjNode, edgW in graph[node]:
                if dis + edgW < dist[adjNode]:
                    dist[adjNode] = dis + edgW
                    heapq.heappush(minHeap, (dis+edgW, adjNode))
                    ways[adjNode] = ways[node]
                elif dis + edgW == dist[adjNode]:
                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod

        return ways[n-1] % mod

-----------------------------------------------------------------------------------------------------------------

12. Longest Happy Prefix

APPROACH 1: (BRUTE FORCE)
ITERATE OVER THE STRING FROM BOTH DIRECTIONS SIMULTAINOUSLY
I.E TAKE TWO POINTERS LEFT, RIGHT
CHECK S[0:LEFT+1] == S[RIGHT:N] --> UPDATE THE HAPPY PREFIX EACH ITERATION IF THIS CONDITION IS TRUE


def longestPrefix(self, s: str) -> str:
        if len(s) == 1:
            return ""
        
        if len(s) == 2:
            if s[0] == s[1]:
                return s[0]
            return ""
        
        hs = ""
        n = len(s)
        left, right = 0, n - 1
        while left != n-1 and right != 0:
            if s[0:left+1] == s[right:n]:
                hs = s[0:left+1]
            left += 1
            right -= 1
        return hs


APPROACH 2: (OPTIMIZED)
KMP ALGORITHM

def longestPrefix(self, s: str) -> str:
        pi = [0]*len(s)
        for i in range(1,len(s)):
            j = pi[i-1]
            while j > 0 and s[i] != s[j]:
                j = pi[j-1]
            if s[i] == s[j]:
                j += 1
            pi[i] = j
        return s[:pi[-1]]

----------------------------------------------------------------------------------------------------------------------

13. Seat Arrangement in a SpiceJet Problem - Online OA February â€˜22

APPROACH:
USE MATHEMATICAL INDUCATION TO PROB FOR N=1
THEN FOR N=2, THEN FOR N=3
USE THESE TO ARRIVE A GENERAL SOLUTION FOR N+1
WE GET ANS = 1 IF N==1 ELSE 0.5

def nthPersonGetsNthSeat(self, n: int) -> float:
        return 1 if n == 1 else 0.5

--------------------------------------------------------------------------------------------------------------------

14. Deletions to make an array divisible.

QUESTION EXPLANATION:
GIVEN TWO ARRAYS NUMS, NUMS_DIVIDE. FIND THE MIN ELEMENT IN NUMS THAT DIVIDES ALL THE ELEMENTS IN NUMS DIVIDE

APPROACH:
I. FIND THE GCD/HCF OF ALL ELEMENTS OF NUMS DIVIDE
II. ITERATE OVER THE NUMS AFTER SORTING IT AND CHECK WHETHER ITH ELEMENT DIVIDES GCD. 
IF YES THEN RETURN I. ELSE RETURN -1 IN THE END

def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        def gcd(a, b):
            if b == 0:
                return a
            else:
                return gcd(b, a%b)

        gc = 0
        for el in numsDivide:
            gc = int(gcd(gc, el))
        
        nums.sort()
        for i in range(len(nums)):
            if gc % nums[i] == 0:
                return i
        return -1

----------------------------------------------------------------------------------------------------------------------------

15. Substrings containing all three Characters


APPROACH: (OPTIMIZED)
SUBSTRING IS VALID IF ALL THREE CHARACTERS OCCUR IN IT
THUS IF FIRST 6 CHARACTERS OF STRING IS THE FIRST OCCURANCE OF ALL 3 CHARACTERS
THEN WE CAN SAY THAT THERE WILL BE LATEST INDEX OF A = 5, LATEST INDEX OF B OR C IS 0
THIS MIN(A, B, C) IS 0 AND TILL THIS POINT ONLY THIS ONE SUBSTRING CONTAINS ALL THREE LETTERS
NOW AS WE MOVE TO THE SEVENTH STRING IF THE NEW CHAR IS SAME AS PREVIOUS ONE WE WILL ADD ONE TO CNT
BUT IF ITS DIFFERENT THEN MIN(A,B,C) GETS UPDATED AND WE ADD IT TO COUNT AND THEN ADD 1


def numberOfSubstrings(self, s: str) -> int:
        cnt = 0
        idx_a, idx_b, idx_c = -1, -1, -1

        for i in range(len(s)):
            if s[i] == 'a':
                idx_a = i
            elif s[i] == 'b':
                idx_b = i
            elif s[i] == 'c':
                idx_c = i
                
            if i > 1:
                cnt += min(idx_a, idx_b, idx_c) + 1
        
        return cnt

-------------------------------------------------------------------------------------------------------------------------------

16. Max Points on a Line

APPROACH:
CALCULATING SLOPES
LOOPING OVER THE POINTS AND GETTING THEIR SLOPES W.R.T THE CURRENT POINT. THEN GETTING THE MAX OCCURING SLOPE OUT OF THEM

def maxPoints(self, points: List[List[int]]) -> int:
        points.sort()
        maxi = 0
        n = len(points)

        for i in range(n):
            slopes = []
            for j in range(i+1, n):
                if (points[j][0] - points[i][0]) == 0:
                    slopes.append("NO")
                else:
                    slopes.append((points[j][1] - points[i][1]) / (points[j][0] - points[i][0]))
            
            if len(slopes) > 0:
                test_list = Counter(slopes)
                res = test_list.most_common(1)[0][1]
                if res > maxi:
                    maxi = res

        return maxi + 1

--------------------------------------------------------------------------------------------------------------------------------

17. VALID SQUARE

APPROACH:
CALCULATE THE FOUR SIDES AND 2 DIAGONAL DISTANCES USING EUCLIDEAN DISTANCE FORMULA
THEN ADD THEM TO A LIST AND SORT THEM
THEN CHECK IF DIAGONALS AND SIDES ARE EQUAL AND RETURN ACCORDINGLY



def distance(self, p1, p2):
        return ((p2[0] - p1[0])*(p2[0] - p1[0])) + ((p2[1]-p1[1])*(p2[1]-p1[1]))

    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
        sides = []
        sides.append(self.distance(p1, p2))
        sides.append(self.distance(p2, p3))
        sides.append(self.distance(p3, p4))
        sides.append(self.distance(p1, p4))
        sides.append(self.distance(p1, p3))
        sides.append(self.distance(p2, p4))

        sides.sort()

        if sides[0] > 0 and sides[0] == sides[3] and sides[4] == sides[5]:
            return True
        return 


------------------------------------------------------------------------------------------------------------------------------
18. Factorial Trailing Zeroes

APPROACH:
THE TRAILING ZEROS IN A FACTORIAL ONLY INCREASE WHEN THE FACTORIAL IS A MULTIPLE OF 5
FOR EX: 5! HAS 1 TRAILING 0, 6-10! HAS 2 TRAILING 0, 10-15! HAS 3 TRAILING ZEROS AND SO ON
THUS WE CAN CHECK IF N//I >= 1 (I = 5)
THEN INCREMENT COUNT BY N//I
AND INCREMENT I BY I*5
FINALLY RETURN COUNT

def trailingZeroes(self, n: int) -> int:
        count = 0
        i = 5
        while n//i >= 1:
            count += n//i
            i *= 5
        return count
---------------------------------------------------------------------------------------------------------------------------------

19. Number of Boomerangs

APPROACH:
ITERATE OVER EACH POINT AND FOR EACH POINT, CALCULATE THE DISTANCE B/W THAT PT AND EVERY OTHER PT
STORE THE DISTANCES IN A DICT/MAP WHERE KEY IS DIST AND VALUE IS NUMBER OF PTS THAT HAVE THAT DISTANCE FROM CURRENT PT
NOW, NUM OF BOOMERANGS THAT CAN BE FORMED WITH CURR PT AS MIDDLE PT IS THEN CALCULATED BY TAKING 
THE NUMBER OF PTS AT EACH DISTANCE AND MULTIPLYING IT BY NUM_PTS_AT _DIST - 1.
THIS IS DONE FOR EACH PT AND RETURN THE FINAL CNT

def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        cnt = 0
        for p in points:
            d = {}
            for q in points:
                dis = (p[0] - q[0])*(p[0] - q[0]) + (p[1] - q[1])*(p[1] - q[1])
                d[dis] = d.get(dis, 0) + 1

            for k in d:
                cnt += d[k] * (d[k] - 1)
        return cnt

--------------------------------------------------------------------------------------------------------------------------------------

20. Split Array into Sequences

APPROACH:
KEEP A COUNTER I.E A FREQ ARRAY OF ALL ELEMENTS AND A MAP
FOR EVERY EL CHECK IF FREQ OF NEXT 2 CONSEC ELEMENTS IS MORE THAN 1 DECREASE ITS COUNTER
ADD THE LAST CONSEC EL IN MAP
IF 2 ELEMENTS FREQ REMAIN, THEN INCREMENT THE COUNTER OF LAST CONSEC OF MAP


def isPossible(self, nums: List[int]) -> bool:
        counter = collections.Counter(nums)
        end = defaultdict(int)

        for num in nums:
            if counter[num]:
                counter[num] -= 1

                if end[num-1]:
                    end[num] += 1
                    end[num-1] -= 1
                elif counter[num+1] and counter[num+2]:
                    counter[num+1] -= 1
                    counter[num+2] -= 1
                    end[num+2] += 1
                else:
                    return False

        return True 

------------------------------------------------------------------------------------------------------------------------------------

21. Minimum Consecutive Cards to Pick Up

QUESTION EXPLANATION:
GIVEN A CARDS ARRAY, RETURN THE MIN NUMBER OF CONSECUTIVE CARDS TO BE PICKED IN ORDER TO GET A SAME CARD
IN OTHER WORDS FIND THE MIN SUBARRAY WITH ONLY 2 COMMAN ELEMENTS

APPROACH:
CREATA A MAP TO STORE ELEMENT AND ITS INDEX
ITERATE OVER CARDS ARRAY AND STORE ITS INDEX
IF A DUPLICATE COMES, CALCULATE THE I - MAP[CARDS[I]] + 1 AND KEEP ON MINIMIZING IT


def minimumCardPickup(self, cards: List[int]) -> int:
        d = {}
        d[cards[0]] = 0
        minAns = 1e9
        for i in range(1, len(cards)):
            if cards[i] in d:
                minAns = min(minAns, i - d[cards[i]] + 1)
            d[cards[i]] = i
        
        return -1 if minAns==1e9 else minAns

-------------------------------------------------------------------------------------------------------------------------------

22. COUNT GOOD TRIPLETS

QUESTION EXPLANATION
(IN SIMPLE TERMS)
WE NEED TO FIND THE SUB-SEQUENCES COMMON IN BOTH ARRAYS

APPROACH:
SUPPOSE A1 = [2,0,1,3] AND A2 = [0,1,2,3]
LETS SAY I POINTS TO 1 IN A1. NOW CORRESPONDING POSITION OF 1 IN A2 WILL BE J
WE FIND THE ELEMENTS COMMON IN BOTH ARRAYS THAT ARE TO LEFT OF 1 IN BOTH AND 
THAT OF RIGHT OF 1 IN BOTH. I.E IN A1 = [2,0] AND IN A2 = [0] (LEFT PART)
A1 = [3] AND A2 = [2,3] (RIGHT PART)
NOW, IF WE SEE THAT FOR LEFT PART WE HAVE ONLY 1 COMMON ELEMENT.
SIMILARLY FOR THE RIGHT PART WE HAVE 1 COMMON ELEMENT.
THUS 1 * 1, ONLY 1 SUCH TRIPLET EXISTS
FOR THIS EXAMPLE, IF TAKE ANY OTHER NUMBER COMMON IN BOTH, ITS PRESENT AT ONE OF THE ENDS
DUE TO WHICH WE CANNOT HAVE A LEFT OR RIGHT PART REQUIRED.

IN GENERAL WE WILL START FROM IDX 1 TILL LEN(A)-2.
FIND THE CORRESPONDING ELEMENT IN OTHER ARRAY. 
CALCULATE THE COMMON ELEMENTS IN LEFT AND RIGHT PARTS. 
GET TRIPLETS FOR EACH ITERATION AND ADD IT TO THE RESULT

TC = O(N^2)


(OPTIMAL)
WE WILL USE A HASHMAP TO STORE INDICIES I.E INDEX OF ARR1[I] IN ARR2
NOW WE NEED TO FIND TOTAL TRIPLETS(X, Y, Z) AS A SUBSEQENCE IN INDICIES WHERE X < Y < Z
FOR THIS WE CAN LOCATE THE MIDDLE NUMBER Y AND THEN COUNT HOW MANY ON LEFT ARE LESS THAN Y
AND HOW MANY ON THE RIGHT ARE GREATER THAN Y
FINALLY WE CAN COUNT GOOD TRIPLETS FOR EACH ITERATION OF Y


def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)

        # storing the idx of nums1[i] in nums2
        my_map = {}
        for i in range(n):
            my_map[nums2[i]] = i
        indices = []
        for num in nums1:
            indices.append(my_map[num])
        
        # calculating left and right count for each y
        from sortedcontainers import SortedList
        left, right = SortedList(), SortedList()
        leftCount, rightCount = [], []
        for i in range(n):
            leftCount.append(left.bisect_left(indices[i]))
            left.add(indices[i])
        for i in range(n - 1, -1, -1):
            rightCount.append(len(right) - right.bisect_right(indices[i]))
            right.add(indices[i])

        # counting triplets
        cnt = 0
        for i in range(n):
            cnt += leftCount[i] * rightCount[n - 1 - i]
        
        return cnt

----------------------------------------------------------------------------------------------------

23. MAXIMUM POINTS IN ARCHERY COMPETITION

APPROACH:
FIND ALL THE SUBSETS USING BIT MASKING THEN TRY TO FILL THEM WITH ARROWS

def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:
        ans = []
        score = 0
        # 2^12 subsets = 4096
        for i in range(1, 4096):
            arrows = numArrows
            temp = [0] * 12

            # Using Bit Masking
            for j in range(11, -1, -1):
                if (i & (1 << j)):
                    if arrows <= aliceArrows[j]:
                        continue
                    arrows -= (aliceArrows[j] + 1)
                    temp[j] = aliceArrows[j] + 1;

            for j in range(12):
                if (i & (1 << j)):
                    temp[j] += arrows
                    break
            
            b = 0
            for j in range(12):
                if temp[j] > aliceArrows[j]:
                    b += j
                if b > score:
                    score = b
                    ans = temp
        
        return ans


(RECURSIVE/BACKTRACKING)

def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:
        maxScore = [0, None]

        def calc(i, rem, score, arrows):
            # Base Case
            if rem == 0 or i == -1:
                if score > maxScore[0]:
                    maxScore[0] = score
                    maxScore[1] = arrows[:]
                return
            
            # Special Case.. Used up all the arrows
            if i == 0:
                arrows[i] = rem
                calc(i-1, 0, score+i, arrows)
                arrows[i] = 0
                return
            
            # Try to compete with Alice if arrows are there
            arrowsNeeded = aliceArrows[i] + 1
            if rem >= arrowsNeeded:
                arrows[i] = arrowsNeeded
                calc(i-1, rem-arrowsNeeded, score+i, arrows)
                arrows[i] = 0
            
            # Skip this section and go to next
            calc(i-1, rem, score, arrows)
        
        calc(len(aliceArrows)-1, numArrows, 0, [0 for _ in aliceArrows])
        return maxScore[1]

----------------------------------------------------------------------------------------------------

24. IPO LEETCODE


APPROACH:
USE 2 HEAPS

def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        # USING TWO HEAPS
        maxProfit = []
        minCapital = [(c, p) for c, p in zip(capital, profits)]
        heapq.heapify(minCapital)

        for i in range(k):

            while minCapital and minCapital[0][0] <= w:
                c, p = heapq.heappop(minCapital)
                heapq.heappush(maxProfit, -1 * p)
             
            if not maxProfit:
                break

            w += -1 * heapq.heappop(maxProfit)
        
        return w

----------------------------------------------------------------------------------------------------

25. People and Secret


APPROACH:
USE DP
CREATE A DP OF SIZE N+1
DP[1] = 1 AS ONLY 1 PERSON KNOWS THE SECRET ON DAY1
DP WILL STORE NUMBER OF PEOPLE TO GET TO KNOW THE SECRET ON ITH DAY

NOW, A PERSON ON DAY I WILL SPREAD THE SECRET FROM I+DELAY DAY TILL BEFORE I+FORGET DAY
THUS, NEW_PEOPLE_SHARING_SECRET ON ITH DAY = DP[I-DELAY]
AND, NUMBER_OF_PEOPLE_FORGETTING THE SECRET ON ITH DAY = DP[I-FORGET]

THUS, NUMBER OF PEOPLE GETTING TO KNOW THE SECRET = NUM_OF_PEOPLE_KNOWING_THE_SECRET + NEW_PEOPLE_SHARING_SECRET - NUM_OF_PEOPLE_FORGGETTING)

NOW, OUR ANS WILL SUM OF DP FROM IDX N-FORGET TO END

def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        dp = [0] * (n+1)
        MOD = 1e9 + 7
        peopleSharingSecret = 0
        ans = 0


        dp[1] = 1

        for i in range(2, n+1):
            newPeopleSharingSecret = dp[max(0, i-delay)]
            peopleForgettingSecret = dp[max(0, i-forget)]
            
            # + MOD TO AVOID UNDERFLOW CONDITION
            peopleSharingSecret += (newPeopleSharingSecret - peopleForgettingSecret + MOD) % MOD

            dp[i] = peopleSharingSecret

        for i in range(n-forget+1, n+1):
            ans = (ans + dp[i]) % MOD
        
        return int(ans)

----------------------------------------------------------------------------------------------------

26.  Invalid Transactions in an EMI


class Transaction:
    def __init__(self, name, time, amount, city):
        self.name = name
        self.time = int(time)
        self.amount = int(amount)
        self.city = city


class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        # The line of code below does the following:
        # 1. we take every element from transactions list (for trans in transactions)
        # 2. as every element is a string, we split it at ','
        # 3. Our class needs to be initialized name, time, amount, city in the order and after splitting the order is maintained, thus we use the spread operator *
        transactions = [Transaction(*transaction.split(',')) for transaction in transactions]
        
        # Sort the list according to time attribute of Transaction class
        transactions.sort(key=lambda t: t.time)
        
        trans_indexes = defaultdict(list)
        for i, t in enumerate(transactions):
            trans_indexes[t.name].append(i)
        res = []
        for name, indexes in trans_indexes.items():
            left = right = 0
            for i, t_index in enumerate(indexes):
                t = transactions[t_index]
                if (t.amount > 1000):
                    res.append("{},{},{},{}".format(t.name, t.time, t.amount, t.city))
                    continue
                while left <= len(indexes)-2 and transactions[indexes[left]].time < t.time - 60:
                    left += 1
                while right <= len(indexes)-2 and transactions[indexes[right+1]].time <= t.time + 60: 
                    right += 1
                for i in range(left,right+1):
                    if transactions[indexes[i]].city != t.city:
                        res.append("{},{},{},{}".format(t.name, t.time, t.amount, t.city))
                        break
        return res

----------------------------------------------------------------------------------------------------

27. All elements of a binary Search Tree

APPROACH:
(NAIVE BRUTE FORCE)
CREATE AN EMPTY LST
PERFORM DFS TRAVERSAL ON BOTH TREES WHILE APPENDING EACH ELEMENT TO THE LIST
FINALLY SORT THE LIST

def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        lst = []

        def dfs(root):
            if root is None:
                return
            
            lst.append(root.val)
            dfs(root.left)
            dfs(root.right)
        
        dfs(root1)
        dfs(root2)
        lst.sort()
        return lst

---------------------------------------------------------------------------------------------------

28. Rhombus Sums in a GRID

APPROACH:
FOR EACH POINT IN GRID WE WILL TAKE THAT POINT AND PUT IT IN OUR PRIORITY Q (SIZE OF SMALLEST RHOMBUS)
THEN INITIALIZE GET FOUR POINTS --> L, R, U, D
THIS IS PASSES TO A CALC() FUNCTION WHICH WILL CALCULATE THE AREA OF EVERY POSSIBLE RHOMBUS 
FROM THAT POINT TILL IT CANNOT BE FORMED ANY MORE
FINALLY WE WILL ADD IT IN THE PRIORITY QUEUE IT ITS NOT ALREADY PRESENT.
IF LEN OF PQ > 3 AND THIS SUM > PQ[0] --> POP THE TOPMOST ELEMENT OF QUEUE AND ADD THIS NEW SUM

FINALLY SORT THE LIST IN REVERSE ORDER AND RETURN

def getBiggestThree(self, grid: List[List[int]]) -> List[int]:
        def calc(l,r,u,d):
            ssum = 0
            c1 = c2 = (l+r)//2
            expand = True

            for row in range(u, d+1):
                if c1 == c2:
                    ssum += grid[row][c1]
                else:
                    ssum += grid[row][c1] + grid[row][c2]
                
                if c1 == l:
                    expand = False
                
                if expand:
                    c1 -= 1
                    c2 += 1
                else:
                    c1 += 1
                    c2 -= 1
                    
            return ssum

        m = len(grid)
        n = len(grid[0])
        pq = []

        for i in range(m):
            for j in range(n):
                l = r = j
                d = i
                while l >= 0 and r <= n-1 and d <= m-1:
                    ssum = calc(l,r,i,d)
                    l -= 1
                    r += 1
                    d += 2

                    if len(pq) < 3:
                        if ssum not in pq:
                            heapq.heappush(pq, ssum)
                    else:
                        if ssum not in pq and ssum > pq[0]:
                            heapq.heappop(pq)
                            heapq.heappush(pq, ssum)


        pq.sort(reverse = True)
        return pq

--------------------------------------------------------------------------------------------------

29. Count Nice Pairs in an Array

APPROACH:
CHANGE THE INEQUALITY TO THE FOLLOWING
NUMS[I] - REV(NUMS[I] == NUMS[J] - REV(NUMS[J])
THUS FROM THIS WE CAN UPDATE OUR NUMS ARRAY SUCH THAT EACH ELEMENT ITS DIFF OF ITS REVERSE AND ITSELF
NEXT WE CAN COUNT FREQ OF EACH ELEMENT IN THIS UPDATED NUMS
FINALLY FOR EACH UNIQUE ELEMENT WE CAN SUM 1 + .. + FREQ-1

def countNicePairs(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            nums[i] = nums[i] - int(str(nums[i])[::-1])
        
        freq = defaultdict(int)
        for el in nums:
            freq[el] += 1

        pairs = 0
        for key, val in freq.items():
            pairs += ((val * (val-1))//2)
        
        return int(pairs % self.MOD)


----------------------------------------------------------------------------------------------------

30. Good People based on Statements

APPROACH:
USING BITMASKING (USED GENERALLY WHEN CONSTRAINT IS SMALL)

WE HAVE N PEOPLE, AND 2 POSSIBLE CASES FOR EVERY PERSON I.E 0 OR 1 (BAD OR GOOD)
THUS WE CAN GENERATE ALL POSSIBLE SUBSETS OF N PEOPLE (2^N) (OUR POSSIBLE TRUTH CASES)

THEN FOR EACH STATEMENT MADE IN OUT STATEMENTS ARRAY, WE CHECK WITH ALL OUR SUBSETS AND 
CHECK WHICH OF THEM ARE NOT CONTRADICTING. AND FOR EACH NON CONTRADICTING STATEMENT WE 
CALCULATE NUMBER OF GOOD PEOPLE AND TAKE MAX OF THAT EVERY TIME.

CONTRADICTION OCCURS WHEN 
A BAD PERSON(0) SAYS A GOOD PERSON (TRUTH CASE) IS BAD
A BAD PERSON(0) SAYS A BAD PERSON (TRUTH CASE) IS GOOD
THE ABOVE STATEMENTS CAN BE MADE USING BIT MANIPULATION
I.E (MASK >> PERSON) & 1 --- > 2 ==> TRUE AND 0 ==> FALSE
OR (1 << PERSON) & MASK



def maximumGood(self, statements: List[List[int]]) -> int:
        n = len(statements)
        res = 0

        def checkGood(person, mask):
            if (mask >> person) & 1:
                return True
            return False


        def validateStatement(mask):
            for i in range(n):
                if checkGood(i, mask):
                    for j in range(n):
                        statement = statements[i][j]

                        if ((statement == 0 and checkGood(j, mask))
                            or (statement == 1 and not checkGood(j, mask))):
                            return False
            return True 


        # Bitmasking 
        for i in range(1, 1<<n): # 1 << n === 2^n
            if validateStatement(i):
                res = max(res, bin(i).count('1'))

        return res
----------------------------------------------------------------------------------------------------

31. Fraction to a recurring Decimal

def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        # Check division by 0
        if denominator == 0:
            return ""
        
        # Check for numerator == 0
        if numerator == 0:
            return "0"

        # Initialize the result and add the quotient and check for negitivity
        res = ""
        if (numerator < 0) ^ (denominator < 0):
            res += "-"
        numerator, denominator = abs(numerator), abs(denominator)
        quotient = numerator // denominator
        res += str(quotient)

        # Calculate and return if remainder is 0
        # Else add decimal point
        remainder = numerator % denominator
        if remainder == 0:
            return res 
        res += "."

        # Initialize a dictionary to check recurrence of remainder
        # Create a while loop until remainder == 0 or its present in the dict
        # Also keep adding the quotient until repetation
        pos = {}
        while remainder != 0 and remainder not in pos:
            pos[remainder] = len(res)
            remainder *= 10
            res += str(remainder // denominator)
            remainder %= denominator
        
        # check for recurrence in dict and get recurrence index and brackets
        if remainder in pos:
            res = res[:pos[remainder]] + "(" + res[pos[remainder]:] + ")"
        
        # Finally return the result
        return res
----------------------------------------------------------------------------------------------------

32. INCREASING TRIPLET SUBSEQUNCE

APPROACH:
(BRUTE FORCE)
TAKE TWO POINTER, FIX THEM SUCH THAT FOR I < J, ARR[I] < ARR[J]
THEN TAKE ANOTHER POINTER AND ITERATE TILL YOU FIND EL > ARR[J]
IF FOUND RETURN TRUE
ELSE INCREMENT I AND J
IF J REACHES END RETURN FALSE

TC = O(N^2)


(OPTIMIZED)
WE NEED TO FIND THE FIRST OCCURENCE OF A SUBSEQUENCE IN INCREASING ORDER
THUS LETS HAVE 2 VARIABLES LOW1 AND LOW2 INITIALIZED TO INF
LOW1 IS THE SMALLEST, LOW2 IS GREATER THAN LOW1

NOT WITH EACH ITERATION WE NEED TO UPDATE THESE SUCH THAT LOW1 < LOW2
FOR EACH EL IN NUMS:
	IF EL < LOW1: --> LOW1 = EL
	ELIF EL < LOW2: --> LOW2 = EL
	ELSE: --> RETURN TRUE
RETURN FALSE

ABOVE IF EL < LOW1 --> WE UPDATE LOW1 AND MOVE WITH NEXT ITERATION
ELSE IF EL < LOW2 -- > EL IS GREATER THAN LOW1, THEN WE UPDATE LOW2 AND MOVE WITH NEXT ITERATION
ELSE: --> EL IS SMALLER THAN LOW2 --> WE FOUND OUR TRIPLET

IF THIS FINAL ELSE IS NEVER EXECUTED --> NO SUCH TRIPLETS AVAILABLE


def increasingTriplet(self, nums: List[int]) -> bool:
        low1 = low2 = float('inf')

        for el in nums:
            if el <= low1:
                low1 = el
            elif el <= low2:
                low2 = el
            else:
                return True
        
        return False

----------------------------------------------------------------------------------------------------

33. Kth smallest in Lexographical Order

APPROACH:
FOR FIRST, WE INITIALIZE CURR = 1 AND DECREMENT K BY 1
THEM WHILE K > 0:
WE CHECK NUMBER OF STEPS TO REDUCE CURR TO CURR + 1 (1 TO 2)
IF THESE STEPS <= K --> INCEMENT CURR BY 1, DECREMENT K BY STEPS
ELSE --> CURR = CURR * 10; DECREMENT K BY 1 (1 TO 10)

FUNCTION TO CALCULATE STEPS TO REDUCE N1 TO N2 WHILE IN RANGE 1 TO N
INITIALIZE STEPS = 0
WHILE N1 <= N
	STEPS += MIN(N+1, N2) - N1
	GETTING NEXT SET OF NUMBER I.E
	N1 *= 10 AND N2 *= 10
RETURN STEPS


def findKthNumber(self, n: int, k: int) -> int:
        curr = 1
        k -= 1
        while k > 0:
            steps = self.getSteps(n, curr, curr+1)
            if steps <= k:
                curr += 1
                k -= steps
            else:
                curr *= 10
                k -= 1

        return curr 

    def getSteps(self, n, n1, n2):
        steps = 0
        while n1 <= n:
            steps += min(n+1, n2) - n1
            n1 *= 10
            n2 *= 10
        return steps
----------------------------------------------------------------------------------------------------

34. MAGICAL STRING

APPRAOCH:
IF N == 0 THEN RETURN 0
INITIALIZE S WITH 1,2,2 AND VAR I = 2
WHILE LEN(S) < N:
  APPEND TO S --> [3-S[-1]] * S[I]
  INCREMENT I

FINALLY RETURN NUMBER OF ONES IN FIRST N ELEMENTS OF S

def magicalString(self, n: int) -> int:
        if n == 0:
            return 0
        s = [1,2,2]
        i = 2
        while len(s) < n:
            s += [3 - s[-1]] * s[i]
            i += 1
        return s[:n].count(1)
----------------------------------------------------------------------------------------------------


35. Non Negative Integers without consecutive ones 

APPRAOCH:
IF WE FOR ONLY 1 BIT POSSIBLE COMBS WITHOUT CONCECUTICE ONES IS 2
FOR 2 BITS (00, 01, 10, 11), POSSIBLE COMBS WITHOUT CONSECUTIVE ONES IS 3
FOR 3 BITS IT WILL BE 5 (8 - COUNT(011,111,110))
FOR 4 BITS IT WILL BE 8

WE SEE THAT IT FOLLOWS FIBONACCI SERIEST
ALSO THE MAX VALUE OF N IS 10^9 WHICH CAN BE REPRESENTED BY 30-31 BITS
THUS WE WILL CALCULATE FIRST 29-30 FIBONACCI NUMBRES

NOW LET  N = 5
IN BINARY N = 5 IS 1 0 1. LETS TAKE 1 AS PREFIX (FROM LEFT)
--> POSSIBLE 2 BITS WITHOUT CONSEC ONES IS FIB(2) = 3
SINCE 2ND BIT IS 0 WE MOVE TO LAST BIT 1. WE HAVE THE COMPLETE BIN REPRESENTATION. THUS WE WILL ADD
FIB(0)
AND WE HAVE REACHED THE END OF OUR BIN REPRESENTATION
THUS OUR ANS IN THIS CASE WILL BE FIB(2) + FIB(1) + 1 = 3 + 1 + 1 = 5

FOR N = 180, THE BINARY REP IS 10110100.
LETS TAKE 1 AS PREFIX (FROM LEFT), POSSIBLE NUMBER OF COMBS WITHOUT CONSEC ONES IS 
LEN(REP) - PREFIX_POS = FIB(7) (RANGE OF 0000000 - 1111111)
LETS TAKE NEXT 1 (PREFIX IS 101), POSSIBLE NUMBER OF COMBS = FIB(5)
LETS TAKE THE NEXT 1, BUT WE SEE THAT PREVIOUS WAS ALSO 1 (THESE ARE CONSECUTIVE ONES POSITION)
THUS WE BREAK AND RETURN OUR ANS I.E. FIB(7) + FIB(5)



def findIntegers(self, n: int) -> int:
        fib = [0] * 31
        fib[0], fib[1] = 1, 2

        for i in range(2,30):
            fib[i] = fib[i-1] + fib[i-2]

        ans = 0
        cnt = 30
        prevBitOne = 0

        while cnt >= 0:
            if (n & (1<<cnt)):
                ans += fib[cnt]
                if prevBitOne:
                    return ans
                prevBitOne = 1
            else:
                prevBitOne = 0
            
            cnt -= 1
        
        return ans + 1

----------------------------------------------------------------------------------------------------

36. Knight in a Chessboard


APPROACH:
CREATE 2 BOARDS CURR_BOARD, NEXT_BOARD WITH VALUE 0.0

NOTE ==> FROM GIVEN POS, PROB OF REACHING THE NEXT POS IS CURR_PROB / 8.0

WE TRY TO GET THE PROB OF REACHING ALL THE POSSIBLE POSITIONS AND STORE THEM ON THE BOARD
FINALLY, OUR ANS IS SUM OF ALL PROBS ON THE BOARD

ALL POSSIBLE MOVES CAN BE SAVED IN A LIST AS THOSE ARE -2,-1 , -2,1 .....
FOR WHICH WE CAN CALCULATE BOUNDS AND IF THEY ARE IN BOUONDS WE CAN TRAVEL TO NEXT POS AND UPDATE ITS PROBS

CURR_BOARD = NEW_BORAD = [[0.0]*N]*N
(CURR_BOARD SHOWS THE CURRENT PROB OF GIVEN/POSSILE POSITIONS)
(NEXT_BOARD IS USED TO FIND THE POSSIBLE POSITIONS AND UPDATE THE PROBS)

FOR I FROM 0 TO K:
-->CURR_BOARD = NEXT_BOARD
-->NEXT_BOARD = [[0.0]*N]*N 

--> TRAVERSE ALL POSITIONS IN BOARD (R,C):
---------> IF CURR_BOARD[R][C] == 0: --> CONTINUE
---------> ELSE: 
--------------->USING POSSIBLE MOVES LIST, CALCULATE NEW_ROW AND NEW_COL VALUES AND 
		CHECK IF THEY ARE INBOUDS
		IF TRUE-->UPDATE THE PROB ON NEXT_BOARD I.E
		NEXT_BOARD[NEW_ROW][NEW_COL] = CURR_BOARD[R][C] / 8.0

FINALLY TRAVEL TEH NEXT_BOARD AND ADD ALL PROBS
RETURN THE TOTAL_PROBS

def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        possible_moves = [(-2,-1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]

        currBoard = [[0.0] * n for _ in range(n)]
        nextBoard = [[0.0] * n for _ in range(n)]
        nextBoard[row][column] = 1.0

        for _ in range(k):
            currBoard, nextBoard = nextBoard, [[0.0] * n for _ in range(n)]

            for r in range(n):
                for c in range(n):
                    if currBoard[r][c] == 0.0:
                        continue
                    
                    for dr, dc in possible_moves:
                        nrow, ncol = r + dr, c + dc
                        bounds = ((0 <= nrow < n) and (0 <= ncol < n))

                        if bounds:
                            nextBoard[nrow][ncol] += currBoard[r][c] / 8.0

        total = 0.0
        for r in range(n):
            for c in range(n):
                total += nextBoard[r][c]

        return total 

----------------------------------------------------------------------------------------------------


37. Matching Subsequences


APPROACH:
(BRUTE FORCE)
FOR EVERY WORD IN DICTIONARY:
    IF LEN(WORD) > LEN(S) --> CONTINUE
    ELSE: ===> ITERATE OVER WORD AND S AT SAME TIME AND CHECK ALL CHARACTERS OF WORD 
               ARE IN S IN ORDER (SUBSEQUECE)
                IF YES --> INCREMENT THE COUNT
FINALLY RETURN THE COUNT



(OPTIMIZED)
CREATE A FUNCTION CALLED IS_SUBSEQUENCE
WORD GIVEN:

FOR EVERY CHAR OF WORD
  FIND ITS INDEX:
  AND FOR NEXT CHAR SEARCH IN S[I+1:]
  IF AT ANY POINT FIND GIVES -1 AS INDEX,-->RETURN FALSE I.E NOT A SUBSEQUENCE



def numMatchingSubseq(self, s: str, words: List[str]) -> int:
def isSub(word):
            idx = -1
            for ch in word:
                idx = s.find(ch, idx+1)
                if idx == -1:
                    return False
            return True
        
        cnt = 0
        for wrd in words:
            if isSub(wrd):
                cnt += 1
        
        return cnt

----------------------------------------------------------------------------------------------------

38. Genetic Mutation


APPROACH:
USING DFS OR BFS WILL SOLVE THE PROBLEM

FOR BFS:
CONVERT LIST OF BANK TO A SET WITH STARTGENE
CREATE A STRING OR LIST OF POSSIBLE MUTATION OPTIONS = [A, C, T, G]
CREATE A QUEUE FOR BFS TRAVERSAL AND A VISITED SET
INITIALIZE A COUNT

WHILE QUEUE IS NOT EMPTY:
--> ITERATE OVER LEN OF QUEUE
-----> POP ELEMENT FROM QUEUE ---> CURR_GENE
-----> IF THIS CURR_GENE == END_GENE --> RETURN COUNT
-----> FOR J FROM 0 TO 8:
-------->FOR EACH CHAR IN POSSIBLE_MUTATIONS:
-----------> CREATE A NEW_GENE = CURR_GENE[:J] + CHAR + CURR_GENE[J+1:]
-----------> IF THIS GENE IS IN THE BANK AND NOT IN THE VISITED SET
----------------> THEN ADD IT IN THE VISITED SET AND APPEND IT TO THE QUEUE
-----> INCREMENT THE COUNT
IF WE EXIT --> RETURN -1


def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        # Converting bank from list to set for faster access
        bank = set(bank)
        # Possible Mutations:
        st = "ACGT"

        # BFS
        queue = [startGene]
        visited = set()
        visited.add(startGene)
        cnt = 0

        while queue:
            for i in range(len(queue)):
                gene = queue.pop(0)
                if gene == endGene:
                    return cnt
                for j in range(8):
                    for c in st:
                        newGene = gene[:j] + c + gene[j+1:]
                        if newGene in bank and newGene not in visited:
                            visited.add(newGene)
                            queue.append(newGene)
            cnt += 1
        
        return -1



FOR DFS 
SIMILAR TO BFS CONVERT BANK FROM LIST TO SET WITH START_GENE
CREATE A DFS FUNCTION WITH ARGS AS CURR_GENE, COUNT
--> BASE CASE: IF CURR_GENE == END_GENE ---> RETURN COUNT
--> REMOVE THIS FROM OUR BANK SET
--> ITERATE OVER EACH CHAR OF CURR_GENE WITH ITS IDX USING ENUMERATE ( CH, IDX):
------> FOR EACH CHAR C IN "ACGT" (POSSIBLE MUTATIONS) (C)
---------> CHECK C != CH AND NEW_GENE := CURR_GENE[:IDX]+C+CURR_GENE[IDX+1:] IS IN BANK 
			AND RES:= DFS(NEW_GENE, COUNT+1) != -1
-------------> IF TRUE THEN RETURN THE RES
--> ELSE EXIT LOOPS AND RETURN -1

FINALLY CALL DFS(START_GENE, 0)



def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
	# DFS
        bank = set(bank)
        bank.add(startGene)

        def dfs(st, cnt):
            if st == endGene:
                return cnt
            
            bank.remove(st)
            for i, ch in enumerate(st):
                for c in "ACGT":
                    if (
                        c != ch 
                        and (st1 := st[:i] + c + st[i + 1:]) in bank 
                        and (res := dfs(st1, cnt+1)) != -1
                    ):
                        return res
            
            return -1

        return dfs(startGene, 0)
----------------------------------------------------------------------------------------------------

39. Count Nodes Equal to Average of Subtree

APPRAOCH:
USING POST ORDER TRAVERSAL
BASICALLY, AVG OF NODE IS SUM OF ITS SUBTREE DIVIDED BY NUMBER OF NODES IN SUBTREE
WE CAN USE POST ORDER TRAVERSAL I.E  LEFT->RIGHT->ROOT
THIS WILL GIVE SUM OF LEFT SUBTREE, NUMBER OF NODES IN LEFT SUBTREE AND SIMILAR FOR RIGHT SUBTREE
FINALLY WE CAN SUM UP BOTH VALUES AND DIVIDE THEM BY SUM OF NODES IN BOTH AND CHECK AND INCREMENT 
THE COUNT

DFS()
IF ROOT EXISIS:
-->DFS(ROOT.LEFT)
-->DFS(ROOT.RIGHT)
--> INITIALIZA ROOT.TOTAL, ROOT.NODES (SUM OF SUBTREE AND NUMBER OF NODES IN SUBTREE)
--> IF ROOT.LEFT EXISTS --> INCREMENT ROOT.NODES AND UPDATE ROOT.TOTAL
--> SIMILAR FOR ROOT.RIGHT
--> FINALLY CHECK IF ROOT.VAL == INT(ROOT.TOTAL / ROOT.NODES) (AVG OF SUBTREE)
-----> IF TRUE THEN INCREMENT COUNT

RETURN THE COUNT AFTER CALLING THE DFS FUCNTION


def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
        
        self.cnt = 0
        
        def dfs(root):
            if root:
                dfs(root.left)
                dfs(root.right)

                root.total, root.nodes = root.val, 1

                if root.left:
                    root.total += root.left.total
                    root.nodes += root.left.nodes

                if root.right:
                    root.total += root.right.total
                    root.nodes += root.right.nodes

                if root.val == int(root.total / root.nodes):
                    self.cnt += 1
        
        dfs(root)
        return self.cnt

----------------------------------------------------------------------------------------------------

40. Maximum Matrix Sum

APPROACH:
GIVEN A MATRIX WITH NEG NUMS, AND WE CAN MULTIPLY ANY 2 ADJACENTS WITH -1 ANY NUM OF TIMES

SO IF WE HAVE EVEN NEG NUMS, THEN WE CAN CONVERT ALL OF THEM TO POSITIVE
BECAUSE EVEN IF THEY ARE NOT ADJACENT, BY CONTINOUS OPERATION OF -1 ON ANY ADJACENT ELEMENTS, 
WE CAN MAKE THEM POSITIVE

AND IF IN CASE NUM OF NEG NUMS IS ODD, THEN WE CAN TOTAL THE ABS VALUE OF EACH ELEMENTS
THEN, WE CAN SUBTRACT 2*ABS(MIN(EL)) (MIN ABS EL FROM WHOLE MATRIX)
BECAUSE CONTINOUS -1 OPERATION WILL LEAVE US WITH ONE SINGLE ELEMENT AS NEG
SO IF WE APPLY THAT OPERATION IN SUCH A WAY THAT THE ONE REMAINING NEG ELEMENT IS THE SMALLEST
IN THE MATRIX, WE WILL GET OUR MAXIMUM SUM

def maxMatrixSum(self, matrix: List[List[int]]) -> int:
        neg_cnt = 0
        total = 0
        minEl = float('inf')
        for row in matrix:
            for el in row:
                total += abs(el)
                if el < 0:
                   neg_cnt += 1
                minEl = min(minEl, abs(el))

        # print(neg_cnt, total, minEl)
        if neg_cnt % 2 == 0:
            return total
        else:
            return total - 2 * abs(minEl)

----------------------------------------------------------------------------------------------------


41. Stock Price Fluctuation 

APPRAOCH:
USE 2 HEAPS (MAX AND MIN) AND A HASHMAP

INITIALIZE LATEST, MAP, MIN AND MAX HEAPS

FOR UPDATE FUNCTION:--> UPDATE THE TIMESTAMP AND PEICE IN MAP
SET LATEST TO CURR_TIMESTEP IF ITS LESS THAN OUR LATEST
PUSH PRICE TO MIN_HEAP AND -PRICE TO MAX HEAP ALONG WITH TIMESTAMP IN BOTH

FOR CURRENT FUNCTION---> RETURN MAP[LATEST]

FOR MAXIMUM FUNCTION--> POP ELEMENTS FROM HEAP UNTIL WE GET THE PRICE OF 
TIME STAMP OF TOP OF MAX HEAP
I.E MAP[MAX_HEAP[0][1]] != -MAX_HEAP[0][0] --> POP
FINALLY RETURN -MAX_HEAP[0][0]

FOR MINIMUM FUNCTION:--> SAME AS MAXIMUM BUT JUST USE MIN_HEAP

class StockPrice:

    def __init__(self):
        self.map = {}
        self.maxHp = [] # max-heap
        self.minHp = [] # min-heap
        self.latest = 0

    def update(self, timestamp: int, price: int) -> None:
        self.map[timestamp] = price 
        if self.latest <= timestamp: 
            self.latest = timestamp
        heappush(self.maxHp, (-price, timestamp))
        heappush(self.minHp, (price, timestamp))

    def current(self) -> int:
        return self.map[self.latest]

    def maximum(self) -> int:
        while self.map[self.maxHp[0][1]] != -self.maxHp[0][0]: 
            heappop(self.maxHp)
        return -self.maxHp[0][0]

    def minimum(self) -> int:
        while self.map[self.minHp[0][1]] != self.minHp[0][0]: 
            heappop(self.minHp)
        return self.minHp[0][0]
----------------------------------------------------------------------------------------------------

42.